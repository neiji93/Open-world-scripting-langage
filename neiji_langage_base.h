



/////
//exemple de code possible avec mon nouveau language script qui va devoir etre
//plus rapide que le C

class .....
{
	//the return statements must obey (???) to E*U^2 <= E* R^2 * I^2 or something
	//else that I found previously (????)
	void void functionName(.....)
	{
		//code....
		
		
		no_return;
		
		//code....
		
		no_return;
		
		//code....
		
		return ....; //???
	}
	
	void void void sealed_void_no_security function2Name(....)
	{
		
		
	}
	
	void void void sealed_void_enforce_almost_impossible_security function3Name(....)
	{
		
		
	}	
}


class TestRapidBehaviourBySecurityOnly
{
	
}

class TestRapidBehaviourBySecurityOnly
{
	
	
}


class TestVideoGameLargeSceneOpenWorldBetterThanEverIndustry
{
	//test dynamic scripted and implicit inheritance
	//maybe there are some other ways but this way is already cool !
	
	
	void void void sealed_void_enforce_almost_impossible_security function3Name(....)
	{
		
		
	}	
	
	//en fait le run ici ressemble a un arbre BSP quon pourrait utiliser dans plein
	//d endroit meme dans plusieurs types d appli et meme dans mon language de prog que jai fait !
	void run(..)
	{
		
		//celui la je lai mis en retard mais l idee est bonne ! C'est de ne pas passer par la
		//racine de larbre BSP
		//le probleme c ke tout en haut il n y a qu un seul noeud, alors comment vais je faire
		//pour virer le maximum de noeud a un moment donne de lexploration de larbre et sachant que
		//ca doit etre au debut ? Hummm, on dirait qu il faut un algorithme !
		
		///ahhhh nonnn ! CA va eviter les cast dans le parcours de l arbre en fait !!! Donc la complexite est extremement
		//reduite ! A voir ! ok, on passe d instructions de programme a des service d un micro noyau !
		//donc a voir cette complexite !!! yeess ! Je m'emporte serieux car il n y a rien de concret
		//pour l instant !
		BaseTypedTypePreventUsingFuturBaseClasses ultimateBase;
		TypeCatch tp;
		
		
		
		
		function3Name(ultimateBase,tp,..);  //On pourra avoir 3 return dun coup mais je ne sais pas si on doit 
							//aussi reflechir au code execute par le processeur comme dans lexemple
							//de l utilisation des fonctions main au lieu de methodes update des scripts c#..!

							//un autre avantage hormi l execution de 3 reutrn dun coup est quon peut donc faire une
							//boucle for a laide implicite de la faille de securite utilise !
							//donc, pour l'instant, le code est plus court mais pas plus lisible.
							
							//il semble que meme avec l utilisation de 3 return d un coup,
							//ce code n est pas optimise mais le faait d utiliser en amont l expression physique
							//que j'ai fait optimise le code qui est ecrit dans ce language en amont !
							//il faut que je fasse des calculs pour cette fonction main !
							
							
		//le mieux pour faire un meilleur profiler est de reparer la faille de securite
		//ca nous forcera malheureusement a rajouter une instrucction mais je viens juste
		//De penser que ca peut aider a avoir un tracing des patching !
		//Profiler->showDebug( n loop of for command); //old and not good
		for(i=0, i < DFS->size(); .... ) //avec cette boucle for, le code est lisible !
		{
			
			function3Name(ultimateBase,tp,..); //call this again and multiple times. It seems pretty to do that. Then I have to find a reason to do it by scratch hehe !
			
			FakeSecurityHole->repair( ultimateBase, tp, tracePatch::getInstance()->getContract(), ... );
		}
		
		//InternalProfiler->showDebug( tracePathc::getInstance());  //je vais peut etre devoir permettre la creation et l utilisation de nouveaux algos pour cette ou ces classes de tracing de patching !
		//InternalAlgorithm->Profiler( tracePatch::getInstance());
		InternalAlgorithms->Profiler( tracePatch::getInstance()->getContract());

	}
};

//////////


//class BaseTypedType //en partant de mon imagination !
class BaseTypedTypePreventUsingFuturBaseClasses
{
	void void void no_return_number_sealed_only_for_security   ultimateFunction(....)
	{
		for(i=0;i<....;i++)
		{
			no_return;
		}
	}
}


class TypeCatch //encore mon imagination et la c un plus c tt, je m ennuis.
{
	BaseTypedType parameter;
	
	void* getType() //the algorithm is based on the well known no_return_number_sealed_only_for_security function algorithm 
					//and use it to get a type
	{
		try{
			
			
		}
		catch(...)
		{
			no_return;
			synchronize;
		}
	}
	
}

//the hole here is based on E*U^2 <= E* R^2 * I^2 then we will take maximum of E.
//This mean that the program will have many types of objects. I said program but This also work for
//other "things" 
class TypeForceUncatchForceSecurityOneHole
{
	//algorithm
	//take as many classes (not objects) as possible with TypeCatch class
	for(i=0; i<....; i++)   //Jai limpression que jai resolu le probleme np complet pour certains cas ! Non ca ne doit pas 
							//etre ca mais je vais regarder quand meme
	{
		
		TypeCatch* tp = new TypeCatch(...);
		Force no C langage behaviour
		buffer overflow not in C
		Force no C langage behaviour
		tp->catchThis(this);
	}
	//...
	//...
}


#define ENQUEUE_DELEGATE_ONE_VAR(.......) \
	class 

#define ENQUEUE_DELEGATE_ULTIMATE_VARS_BY_IMPLICIT_DYNAMIC_INHERITANCE(.....) \
	class ##nclassname##_baseClass { \
		BaseTypedType type1Test; \
		....\
	}\
	class ##classname##BaseClassEnforceNoType { \

//2500 security holes fixed
class UltimateEnforceFuturThings { //can be anything like a type or even a class or an algorithm
	NeuralNetwork Brain2500; //Ca c cool ! Le seul probleme c ke j utilise encore le nombre 2500 !


	//eh oui en dessous malgre le fait que jutilise le nombre 2500 a l interieur de la
	//classe, je vais devoir tout de meme essayer de corriger 2500 failles de securite
	//pour la securite du language lui meme !!7
	//euhhh, ou sinon je vais trouver un moyen plus rapide comme passer a la chaise electrique !
	//oui, ca aussi ca marchera !!
};


class ElectricChairForSecurityFuturThings { //il semble que je nai plus besoin de corriger 2500 failles de securite !
	
};


#define ENQUEUE_PATCH_WITH_ASM(classname, stringToPatch, afterPatchingString, code)\
	public class Managed##classname##Patch \
	{	\
		void execute()\
		{\
			asm{\
				code\
			}\
		}\
	}
	
//je dois trouver des codes source qui me donne comment l assembleur peut
// utiliser des isolate !

public class NativeMessageSender{} //...
	