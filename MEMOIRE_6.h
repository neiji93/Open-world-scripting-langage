

/*
dans mon language de prog, on peut avoir 6 types de memoire car log(100 000 chiffre) a
peu pres egale a 6 (5,999...). Il existe deja 3 types de memoire en C. Maintenant, 
faisons au hasard les 3 autres restants a partir de mon imagination car j utilise encore
tout de suite log(x) !

1/memoire dynamique altérable d information 1
2/memoire coordonnees de remplissage du vide. Utiliser un algorithme d ordonnanceur aussi 
dans une partie de la gestion de cette memoire. Euhhh, non jaime pas on abandonne cette idee !
2.1/ memoire virtuelle de fichiers ....

3/memoire non alloue de construction d algorithmes !

Ces 3 nouveaux types de memoires paraissent betes a premiere vue, mais si on le "melange"
avec la richesse de mon language, on devrait arriver a beaucoup de choses comme voir
la lisibilité du code, la rapidite (encore plus rapide) des dernieères lignes de codes,
la rapidité d execution des algorithmes ou des modeles (supercalculateur), etc....

je dis etc car je n'ai pas encore vu la totalite de la richesse de ce language !

*/


//je peux faire ca car il n y a que 6 types de memoire
//et les 3 premiers types de memoire sont ceux qu C. Donc il en reste 3. Mais comme 2 dentre eux
//peuvent etre interprete comme des optimisations d algorithmes, ce define va donc renvoyer
//une seule memoire. L utilisation du define ici est utile ici car on evite la compilation.
//et, de ce fait, c'est plus rapide meme si ca ne dit pas que c est cette memoire la plus
//rapide d utilisation. Mais l utilisation massive dans le code des programmes du programmeur
//rendra cette memoire tres rapide et meme plus rapide que les autres a ce moment.
// sinon on n avait pas
//du tout besoin d un define sans ces lignes de define.
//Mais il faut que fasse les specifications du code driver car mon language est aussi un language
//de drvier.
#define BRUTE_FORCE_SELECT_MEMORY( .......) \
	
	
	
//en dessous, bien qu on ait supprime des focntions intrinseques du C, c est plus securise
//d empecher de tracer les patch. On peut le faire de maniere entierement basique.
typedef PatchPreventAlgoithm* basePatchBaseClassPreventExtensibility;

//en dessous, il est toujours possible dans mon language, qui doit etre riche, de pouvoir
//tracer les patches ! On va le faire avec les 3 types de memoires du C.


//en dessous, pour pouvoir tracer les patch avec les 3 derniers types de memoire, on va devoir
//rendre ces memoires tres rapide et alors on pourra tracer n importe quooi !

// Avec tout ce que je viens de faire ici, on a cree un systeme de patch securisé !
//Cela  ressemble a du code OS. Mais pour pouvoir utiliser les patch ou le tracing de patch
//comme en C. On va devoir offrir la possibilité de patch toutes les fonctions et classes et define
//de ce fichier sans pour autant toucher aux differents types de memoire que jai cree. Sur ce derniers
//point, cela nous renvois a supprimer encore plus de fonctions intrinseque du language C !!!
//Je pense qu il faudra reecrire du code assembleur des fonctions du C ! Essayons alors de
//rendre ce code asm du C plus rapide qu en C ! Cela permettra aux programmeurs finales qui utilisent
//mon language a utiliser des algorithmes de patch ou de tracing de patch plus long et qui s executera
//donc tout aussi rapidement que si le code etait court. 
//En ayant dis tout cela, il en resulte que si le code est long, on peut utiliser les memes
//types de patches et/ou tracing de patch comme en C !

//il faut tout de meme empecher que ce code ressemble a du code OS	


//ah, ca y est ! J ai trouve comment ne pas utiliser de technolgies d OS : comme le code
//sera plus long que dans un autre language, cela permettra neanmoins d avoir plus d interoparabilité
//du code source de ce language avec d autres language ! En somme, ce language ne peut fonctionner
//tout seul ! Cela n est pas grave car nous a la base, ce que l on voulait c esr que ce soient
//les dernieres ligne de code dun programme ecrit en ce language qui soient executé plus
//rapidement qu en C ! Pourtant, j avais reussi a rendre les autres parties du code plus rapide
//mais tout tombe a l eau sauf les dernières lignes de code ! C est pas grave !
//Ok, Ok ! Pour augmenter la taille du code seulement dans ce cas, il faudra ne faire que 
//des injections (de dependances ?). Mais je ne sais pas si on peut utiliser aussi la technologie
//des driver.
//A partir de ca, suite en dessous qui reprend des phrases d avant

//en dessous, bien qu on ait supprime des focntions intrinseques du C, c est plus securise
//d empecher de tracer les patch. On peut le faire de maniere entierement basique.
typedef PatchPreventAlgoithm* basePatchBaseClassPreventExtensibility;

//en dessous, il est toujours possible dans mon language, qui doit etre riche, de pouvoir
//tracer les patches ! On va le faire avec les 3 types de memoires du C.
class InjectorPatcherPreventBaseClass  //empecher les classes de base est une utilite et une specification de mon
//language, donc regarder les commentaires d avant meme si c dans un autre fichier
{
public:
	[inject]
	void injectForPatch( );
	
	//pas otpimale la solution en dessous mais ca aura une vitesse comme en C ! Peut etre meme
	//Dans les dernières lignes de code
	{inject]
	void injectIntoThisMemoryAndPatchIt(....)
	{
		
	}
	
	//pas besoin d annotations ici donc en plus ca donne un code plus typé C !
	void injectToDriverOnly( .... )
	{
		
	}
	
	//cas de l injection dans plusieurs driver. Toujours fortement typé C !
	void injectToDriversOnly(...)
	{
		
		
	}
};

//je ne sais pas si ca va etre utile en dessous car j utilise des contre techniques d OS
//pour empecher d utiliser les drivers dans les patch qui peuvent etre fait avec des injections (
//de code ? De dependance ?). Je veux dire qu on ne pourra utiliser ces 3 technologies a la fois ici !
class InjectorPatcherPreventDrivers
{
	
	
}




//Pour l instant, je vais toujours utiliser log(x). Donc la, j avais une idee et ce sera la derniere
//car je vais encore utiliser log(x) pour calculer le nombre d idees a rajouter (malgre la richesse de
//mon language). Donc ce sera ici la dernière idée de ce fichier pour la gestion de la mmémoire !
//Donc voila, l idee est d utiliser des techniques d' OS qu'on aura denaturé des OS pour avoir 
//certaines propriétés de ce language ! Je vais prendre des idées au hasard, toujours grace a log(x) donc !
//L idee au hasard serait d utiliser des techniques d OS pour patcher. Donc le patching dans mon
//language sera une technique ancienne d OS ! Quelles avantages peut-on tirer de ca ? On peut
//en tirer que l interoperabilité du code sera compatible avec mon language et ceci avec une fortement
//"probabilité !"
