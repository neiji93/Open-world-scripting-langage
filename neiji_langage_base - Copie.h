



//there are 2 ways to implement energy retrieving in your programs.
//first by #define
//second by internal classes
//at the moment, i dont know if using security technologies will be good !

#define ENQUEUE_GET_ENERGY
#define ENQUEUE_GET_ENERGY_CODE_FROM_SCRATCH  //on devrait avoir des choses mutliples
												//et tres pousse avec ca je pense ! hihi !
#define GEt_SECOND_TERM_ENERGY

#define GET_ENERGY_FROM_ISOLATE

#define GET_ENERGY_FROM_ISOLATE_CONTRACT_ANNOTATION //whaoouh !




/////
#define NEIJI_LANGAGE_SCRIPTS_ON	//peut etre quon peut utiliser des trucs de ce genre !



//ici file AnimationGeneratorForSkeletonAlgotithm

class AnimationGeneratorFromSkeletonAlgorithm
{

	//le probleme ici c ke je dois utiliser plusieurs lignes de code que je devrais
	//utiliser tout le temps ou presque dans mes futurs programmes !
	//comment remedier a ca ??!!!
	//ahhh ouiii ! Si je fais un ENQUEUE_ quelque part ailleurs dans le code source,
	//meme dans un autre fichier, eh bien, ce que je fais la sera pardonnable ! YESSS !
	public void run()
	{
		//in order to prevent bottlenecks in the code that can produce coubter performances,
		//it is best to isolate and create a process or a thread first !
		std::move(...)
		
		GET_ENERGY_FROM_ISOLATE_CONTRACT_ANNOTATION( ....)
		GEt_SECOND_TERM_ENERGY(...)
		
		EnforceMathsByPointLight_1* ....;
		
		//internal algorithms got from some EnforMathsByPointLigh_1 outputs
		//you have to check your algorithm first if this feature is possible in your code
		//This is another feature of my new scripting programming language ! Something added to it now !
		EnforceContinueAlgorithmPAttern_1_optimizer2*
		
		
		
	}
	
	//en fait, deja la cest la version 2 et j'ai remarque que mon language de prog scripte
	//ressemblait a un code en C de driver (linux par exemple). Alors quelles seraient
	//les avantages d avoir un language de prog qui utilise un style de code driver ?
	// Facilite d ecriture ?????? Je vais trouver des mots au hasard pour dire qu il y a une
	//facilite d ecriture ! 1/ Le code driver peut permettre d eviter l utilisation des annotations !
	//euuhh je sais pas.
	//2/ le code driver etant de l injection controle et comme en physique on doit voir le referentiel
	//pris pour faire le code source,....euh trouve quelque chose mujdate !
	//3/ de la meme maniiere que le 2 mais cette fois avec le code math, et donc avec
	//les point lights mathematiques, l injection sera plus rapide avec ce procede pris des driver
	//car.... c une intuition mais c vrai ! A paufiner mujdate !
	//super !! une injecrtion plus rapide !!!
	public void run2(...)
	{
		
		
	}
	
	
	
	//version 3 (run3)
	//avec cette signature de function qui est un main, il est plus logique et surtout completement
	//du style de code conventionnel d'appeler des fonctions de driver !
	//Peut etre que je devrais penser au cas ou on ne met pas d annotations ou cette signature
	//de main....A voir !
	//Mais attention !! Que faire alors les define utilise en bas ?? A voir !!
	//ah jai une idee pour le dernier point ! On peut utiliser des variables statiques peut etre
	//??? humm, en tout cas en faisant ca le code est plus logique mais moins lisible j'ai
	//l impression !
	[ExplicitEndEffector]
	public static void main(String[] args)
	{
		//je pense ici quil peut y avoir plusieurs manieres d implementer
		//cette fonction ! C'est un algorithme ! 
		//1/ on peut utiliser std::mvoe
		//2/ on peut utiliser des export_symbol_gpl
		//3/ Je men rapelle plus
		//A noter qu on devra les mettre au bon moment a chaque fois !
		//Oui, c est un algorithme !
		//C bizarre c'est en meme temps du code driver et aussi un algorithme !
		//Quel serait l avantage de faire ca ! A moi de trouver plein de bienfaits !
		//je pense que ca peut permettre de "connecter" les differentes dernieres lignes
		//de code (end effectors) a premiere vu et, donc, d augmenter la taille du code
		//qui peut etre executé plus vite qu'en C ! Mais pourquoi faire ca alors ?
		//Ah oui ! JE vois ! C est la separation du code !!!
		//WHAOUH ! Donc avec ce language, le code est encore plus separe qu en java ou en C++ 
		//qui utilise principalement les classes (POO)
		//malheureusement, la POO est deja bien faites ! Mais jai une idee : donner des noms
		//de classes aux processus !!!
		//comme syntaxe, ou plutot comme lignes de code possible dans
		//ce genre de fonction, on peut avoir un truc du genre :
		/*
		ProcessA* pA = new this();
		//les smart pointer semble differents aussi mais avec toujours l utilisation
		//des modeles !
		// pour combiner 2 this, on doit recuperer les variables qui nont pas ete utilise 
		//dans l energie ! hummm, la ce n est pas optimise pour s executer plus vite que le C !
		//pour l instant jai ca en tete !
		//donc
		std::move( GEt_ENERGY_SECOND_TERM() + GET_ENERGY_FIRST_TERM );
		std::move(GEt_ENERGY_SECOND_TERM() + GET_ENERGY_FIRST_TERM, ....); //le fait ici d utiliser
				//un deuxieme membre en parametre du define permet de .... (trouver une explication au hasard !)
		EnergySerilizer::getInstance()->fromProcess( this ); //?? ou EnergySerilizer::getInstance()->fromProcess( processA );
		*/
		//j ai l impression que la serialisation est plus rapide dans ces process qui sont des classes.
		//c est deja beaucoup mais utlimement, j ai l impression que le code source est encore
		//plus separe que si n importe quel algorithme aurait ete implemente quel autre language
		//que celui ci ! hummm, Oui, mais mettre des process partout n est pas idealement logique !
		//il faut que je trouve un mecanisme en plus ! Pourquoi ne pas utiliser la securite
		//des systemes informatique pour ca ??? Ok, c cool mais esperons que ca ne ralentira pas le code !
		//Humm, ok, ca donnera la meme vitesse qu une serialisation normale !
		//Donc on n appelera pas les classes comme cet exemple : class ProcessA*
		//mais : class IsolateA ou plutot InternalIsolateA
		//euh, lachons ca pour l instant mais j ai compris qu apres la serialisation, les pipes 
		//S executent plus rapidement ! En somme, si l on met trop de pipes, la vitesse sera la meme
		//qu un prog c. Mais pour la separation du code, on va dire que les classes "BigSystem" seront des
		//Supercalculateurs ! Donc les algos devront etre dapaté aux supercalculateurss et aux drivers !
		//whaooouuh !
		std::move(this);
		
	}
	
	//ver 4
	...
	{
			//en fait, si on utilise std::move, je pense que comme dans le cas des anciennes fonctions
			//GLSL, ca serait contre productif et ca transformerais donc quelque chose de fortement
			//conseille en depreciated par la suite ! En somme, on ferait une erreur !
			//mais je pense aussi que ca peut rendre les programmes de ce language plus securisé !
			//AHH D ACCORD ! Il faudrait donc que ca s accrode avec l algorithme de la base du
			//language qui devrait etre a recompiler et aussi l algorithmique des super computer !
			//EUUUUH ? J ai pas oublié d autres choses ???
			
			//NON ! NON ! Il faut empecher tout ca ! Donc ca c est une faille de securite du language !
			//on peut peut etre resoudre le pb en mettant un constructeur speciale a la place !?
			//euhh, en fait, j'ai l'impression que ca corrige juste un peu le pb ! Mais c tres lisible
			//et donc c bon ! Ceux qui veulent faire des applications de securité n'auront qu'a travailler
			//leurs cerveaux !
			ClassA special_classe_1 = new ClassA( std::move(this), ....,....);
			//humm, en dessous c une autre possibilite !
			//ClassA special_classe_1 = newWithoutProcess ClassA( ....); //completement idiot celui la !
			
			//euh en bas c deja mieux !
			classA special_class_1 = new point_light classA(...);
			classA special_class_1 = new referential_physics classA(....);


			//ne pas oublier la rapidité des pipes !
			...= programOrProcessA | -fromJson programOrProcessB | .......................;
			
			
			
			//il semblerait qu avec tout ca, le patching est une technologie tres intrinseque de ce
			//language meme au debut de toute instruction ou un/des trucs du genre !
			//est il possible maintenant d integrer de nouvelles techniques de patching en prenant
			//en compte les formules de project management comme le TameFlow ??! Essayons !!!
			
			//une technique possible mais pas la seule serait d utiliser des new point_ligt.. ou
			//new referential ... avec les pipes en meme temps ! Comme l energie se propage, toute
			//formule d energie peut se propager ! Mais a quoi ca va servir de propager de l energie ?
			//Je dis ca au hasard mais peut etre que c est vrai, mais ca va patcher les premieres
			//lignes de code !
			//alors maintenant, comment gerer le patching a son niveau le plus naturelle d aujourdhui
			//et donc sans ma technologie ?
			//Eh bien, je n'ai pas pense a l algorithmique avec les technologies de driver
			//mais peut etre qu on peut faire un truc comme regedit !!!
			
			
			//je viens de penser a un truc super important : grace a ce language qu on va coder en C,
			//et bien, il y aura des foncrions du language C qu'on ne devra pas utiliser !!!!
			
			
			
			//ver 5 : tout dans la version 4 est bon ! Et maintenant on va essayer d optimiser 
			//les dernieres lignes de code du scripting de jeu video open world avec ici les IA PNJ
			//dans ce cas ca sera le cas de l utilisation de reseaux de neuronnes.
			//Humm, il y a une amelioration que je peux faire mais je dois penser 
			//a aussi rendre correct cette technolgie que je vais decrire avec la terchnologie
			//des driver et de l algorithmique !
			//C est une annotation : [DesContainer(....)]   on aurait put utiliser async aussi.
			//Encore une fois, c est une condition de vitesse d execution car en fait, malehreusement,
			//cela rend ces lignes de code tout aussi rapide qu en C mais sans utiliser cette tehcnologie
			//L execution aurait ete plus rapide. J ai pense a cette technologie car je voulais
			//dire au programme ou il devait envoyer les output bien que,, comme dans le cas des
			//container, les données peuvent ne pas arriver a destination ! Dans mon language,
			//cela devra etre dans le cas de failles de securite ! Jai pense a cette tehcnologie
			//Avec des syntax de code comme :  std::move processPBRMeshRenderer;
			//								   //processPBRMeshRenderer.prototype =...
			//									processPBRMeshRenderer.prototype; //cette syntax est meilleur
			//Cette syntax permet d eviter les container car on evite les new Pointlight ou new referentialPhysics
			
	[DestContainer(PBRMeshRenderer)]
	[ExplicitEndEffector]
	[VectorizeDriver]	//je viens juste d ajouter ca car jai la possibilite d utiliser des technolgies
						//de driver. Je nai pas encore pense a l algorithmique. Mais une chose semble
						//apparaitre : il semble y avoir plus de lignes d annoations que de lignes de code !
	
	//l utilisation de plus d annotations rend peut etre le code tres securitaire avec en plus  le fait
	//que les algorithmes a l interieur de ces fonctions main sont invisibles !
	//Les aalgorithmes pourraient etre mis dans le code sourcee de ce language !

	public static void main(String[] args)
	{			
		

			MyAINeuralNetwork nn = new point_light MyNeuralNetwork(...);
			//classA special_class_1 = new referential_physics classA(....);


			//avec ca en dessous, on n aura pas besoin d appeler les fonctions du reseau de neurones
			//car on va sauvegarder l algorithme qui a permi de vectorizer le NN ou les fonctions
			//de cette classe de reseaux de neuronne. C est ici une optimization de lignes de code
			//mais je ne pense pas que cela va augmenter la vitesse d execution !
			//Mais le code sera plus court et donc plus lisible bien que l algorithme devien invisible.
			//En fait, il y a un avantage, c est que lagorithme invisible augamente la securite du
			//programme !
			VECTORIZE_POINT_LIGHTS() //ou dans d autres cas : VECTORIZE_REFERENTIAL_PHYSICS()
				


			//maybe we can concatenate objects in an array with this langage !
			//as there are some supercomputer features, maybe we can do it with processes
			//at the same speed as in a regular low level langage. I mean that it may delete
			//supercomputer optimization although it allows supercomputer type lines of code !
			ArrayProcess p = programOrProcessA | -fromJson programOrProcessB | .......................;
			
			./driver(
			
				GET_ENERGY_FROM_ISOLATE_CONTRACT_ANNOTATION;	//comme c est un nouveau language, l utilisation des define a l'interieur de ./driver
				//n est pas mauvais ! Le seul truc mauvais serait de ne pas rajouter des annotations en plus en haut
				//pour avoir plus d annotations que de lignes de code. En faisant ca aussi, on force
				//l extensibilite du programme ! Mais ca n a rien a voir avec les patch mais ca ressemble aux delegates !
				
				
				//p secureInject PBRMeshRenderer;
				p secureAnnotation PBRMeshRenderer; //cette syntax semble meilleur mais je n en suis pas sur !
			);
	}
	
	
	//ver 6 : en fait je ne vais pas faire de ver 6 mais plutot ici je voulais dire
	//que ce que j ai fait dans la version 5 peut servir à coder un OS securisé !
	//Il y aura donc selon mon travail actuelle deux type d implementation de reseaux de neuronnes
	//qui pourraient servir par exemple a dire si un programme peut s executer en mode kernel !
	//A noter que sinon on peut utuliser des modeles ou modeles locaux mathematiques ou physique
	//Donc ca fait 4 possibilité au total ! 
	//La deuxième implémentation possible qui est different du code de ver 5, est le meme sauf qu il 
	//n y a pas ./driver je pense !
	//Pour les autres cas, l utilisation dans le futur et pour longtemps de log(x) demontre
	//quon n a pas forcement besoin de modeles !
	
	
};



//En dessous, ca peut etre mis dans un autre fichier !
ENQUEUE_CLASS_OBJECT_....( AnimationGeneratorFromSkeletonAlgorithm )
static AnimationGeneratorFromSkeletonAlgorithm* g_p...;
AnimationGeneratorFromSkeletonAlgorithm::.... = .... ;
EXPORT_SYMBOL_GPL(....)


ENQUEUE_CLASS_OBJECT_...._FUNCTION_1( AnimationGeneratorFromSkeletonAlgorithm::run )







