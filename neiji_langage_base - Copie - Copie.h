
//dans le code ./driver on pourra faire un set implicit de l energie
//Si l on veut un set explicite de l energie, il faudra le mettre exactement vers les
//20 premières classes ou fonctions de classes qui vont avoir des heritages (du fait que de nos
//jours on peut obtenir log(x) pour x a 100 chiffres dans un pc commerciale haut de gamme).
//Pour recuperer l energie explicitement, on n aura pas besoin de le faire apres 100 heritaages !

//hummmm, tout cela ressemble a un pattern UML mais en codant differement et donc on "brouillant"
//les pistes haha !


//14-07-2024.... Je pense que si j arrive a organiser la memoire avec log(x) et E*U^2=...
// ou en ajoutant un autre "truc" mathemaique, avec des principes math ou physiques,
// on aura trouver quelque chose de meilleur que l arbre binaire de recherche !!! SUPPPEEER !

//15-07-2024 Peut etre qu il faudrait trouver un nouvel algorithme de donnees anonymes pour les
//supercalculateurs ! J'ai pense aussi a utiliser fakeInjectToStop qui doit tansformer des entrees
//d instructions en donnees anonymes pour que le plus tot possible on arrete d executer la suite
//des instructions ! Ca doit etre un truc de super calculateurs !
//d un autre cote, on pourra alors faire un SET ownership du code qui etait devenu anonyme...?!!!
//Ca permettrait de securiser le programme globale ! AHH OKKK ! Vu que ca securise le programme
//globale, ca va donc aussi permettre d executer du code plus rapidement quen C ! Il faut juste
//trouver un moyen de le faire avec ces specifications ! A noter que ce nest pas le premier truc
//que je trouve pour executer du code plus rapidement qu en C ! Une fois j avais pense a enlever certaines
//fonctions de la librairie du language C !
//J ai trouve un moyen d utiliser tout ce que j ai fait juste avant mais cest pas tres poussee
//Car ca ne permet de retrpuver que les "pointeurs" qui sont au debut du programme ! En effet,
//comme les differetns algorithmes des programmes peuvent apparaitre dans le code source de mon
//nouveau language, eh bien, on pourra retrouver les pointeurs avec cette propriétés et donc en
//utilisant le nouvel algo de donnees anonymes mais pas 
//les algorithmes qui apparaissent vers la fin du programme ou qui sont a la suite de nombreux 
//algo mis déjà dans "la pile du code source du nouveau language" !
//AHHHHHH BAHHH C BIEENNNN ! On execute deja les dernieres lignes de code plus rapidement qu en C
//et maintenant le debut du programme s execute aussi plus rapidement qu en C !
//OUEEEE ! Le seul probleme, mais ce n est pas un probleme, c kil faudra le dire au programme utilisant
//mon language aussi dans les dernieres lignes de code du programme ! HUMMMM !
//En sommme, pour l instant, c est le milieu du programme qui ne s executera pas rapidement ! Merde !
//Pour l instant, il y a un avantage : C ke le code source du programme devient plus lisible
//car on separe debut, milieu et fin du programme !
//on aura un fichier ownershipsNeiji.haha
//static void* ....ownership;
//une solution pour l execution des algorithmes au milieu du prgramme serait d ajouter des pointeurs
// des algorithmes (ou classes)
//a executer apres la fin de l execution du programme (ou classe en cours) en cours.  Ca ressemble a la
//methode du saut de pointeur ! Avec les annotations ou les driver, sans ecrire de ligne de code peut etre
//  c donc possible !


	[DestContainer(PBRMeshRenderer)]
	[ExplicitEndEffector]
	[VectorizeDriver]	//je viens juste d ajouter ca car jai la possibilite d utiliser des technolgies
						//de driver. Je nai pas encore pense a l algorithmique. Mais une chose semble
						//apparaitre : il semble y avoir plus de lignes d annoations que de lignes de code !
	
	//l utilisation de plus d annotations rend peut etre le code tres securitaire avec en plus  le fait
	//que les algorithmes a l interieur de ces fonctions main sont invisibles !
	//Les aalgorithmes pourraient etre mis dans le code sourcee de ce language !

	public static void main(String[] args)
	{			
		

			MyAINeuralNetwork nn = new point_light MyNeuralNetwork(...);
			//classA special_class_1 = new referential_physics classA(....);


			//avec ca en dessous, on n aura pas besoin d appeler les fonctions du reseau de neurones
			//car on va sauvegarder l algorithme qui a permi de vectorizer le NN ou les fonctions
			//de cette classe de reseaux de neuronne. C est ici une optimization de lignes de code
			//mais je ne pense pas que cela va augmenter la vitesse d execution !
			//Mais le code sera plus court et donc plus lisible bien que l algorithme devien invisible.
			//En fait, il y a un avantage, c est que lagorithme invisible augamente la securite du
			//programme !
			VECTORIZE_POINT_LIGHTS() //ou dans d autres cas : VECTORIZE_REFERENTIAL_PHYSICS()
				


			//maybe we can concatenate objects in an array with this langage !
			//as there are some supercomputer features, maybe we can do it with processes
			//at the same speed as in a regular low level langage. I mean that it may delete
			//supercomputer optimization although it allows supercomputer type lines of code !
			ArrayProcess p = programOrProcessA | -fromJson programOrProcessB | .......................;
			
			./driver(
				SET_EXPLICIT_ENERGY_TERM(nn->.....); 
				EXPORT_SYMBOL_GPL(....)
			
				GET_ENERGY_FROM_ISOLATE_CONTRACT_ANNOTATION;
				
				//p secureInject PBRMeshRenderer;
				p secureAnnotation PBRMeshRenderer; //cette syntax semble meilleur mais je n en suis pas sur !
			);
	}
	
}



//en dessous, c le cas du test du crash de mugen en temps reel.
//L algorithme prevoit d annuler un coup ou une defense entre par le oypad si le
//jeu se crash ! NON NON ! Ca c le boulot du game designer ou gameplay programmer !
	[DestContainer(PBRMeshRenderer)]
	[ExplicitEndEffector]
	[VectorizeDriver]	
	public static void main(String[] args)
	{			
		
			//javais deja fait des recherches sur l utilisation de log(x) d une certaine
			//maniere pour concatener les sorties de deux ou plusieurs réseaux de neurones !
			//Le seul truc maintenant c de savoir comment faire des modeles locaux.
			MyAIRealTimeCrashNeuralNetwork nn = new point_light MyAIRealTimeCrashNeuralNetwork(...);
			//classA special_class_1 = new referential_physics classA(....);


			VECTORIZE_POINT_LIGHTS() //ou dans d autres cas : VECTORIZE_REFERENTIAL_PHYSICS()
				


			ArrayProcess p = programOrProcessA | -fromJson programOrProcessB | .......................;
			
			./driver(
				SET_EXPLICIT_ENERGY_TERM(nn->.....); 
				EXPORT_SYMBOL_GPL(....)
			
				GET_ENERGY_FROM_ISOLATE_CONTRACT_ANNOTATION;
				
				//p secureInject PBRMeshRenderer;
				p secureAnnotation PBRMeshRenderer; //cette syntax semble meilleur mais je n en suis pas sur !
			);
	}
	
}


//Je pense qu il faudra encore utiliser log(x) pour definir la complexite de lexecution
//dans le desordre des codes du debut, milieu et fin. Donc, la, jai deux fois l utilisation de 
//log(x) et E*U^2=... en sachant que ce n est pas la theorie de l information !
//Donc si ce nest pas la theorie de l information, on devra utiliser un modele locale avec log(x)
//qui doit etre modifie d une certaine facon ! Ok !!!! J ai compris !!! Trouvons une relation
//entre les modeles locales et log(x) !!! Oui c vrai on utilise encore une fois log(x)
//, c un vrai bombardement ! N oublions pas que tout ca c pour determiner la complexite
//d execution par un supercalculateur de code dans le desordre ! Je nai pas encore pris en 
//compte l algoirhtme qui gere ca donc c a faire !!!!
//ok, jai des idees avec log(x) : je pense qu on peut remplir la matrix du modele locale
//avec des composition de fonction avec log(x) tout en supprimant des classes mathématiques
//pour rendre le modele bizarre. En faisant ca, on maximise la ressemblance de ce modele
//avec les modeles de Navier stokes meme si c juste un peu ou infiniment petit !
//En meme temps, en gardant tout de meme une partie de l'aspect mathematique, on peut donc
//en meme temps deduire la complexité de la separation des lignes  de code !
//OLALALA ! en pensant a cela je viens de me rendre compte qu en n utilisant aucune donnee en entre
//De nimporte quel programme, et donc en se basant sur le calcul de la complexité, l execution
//du code source est au final en "truc nouveau" en informatique ! Bah on va deja l utiliser
//dans notre super calculateur !  Ahhh, jai une idée ! On va l utiliser comme un pattern ou comme
//EXPORT_SYMBOL_GPL ou smart pointer ou smart pointer validation ou autre ! Je vais y reflechir !
//ok jjai compris ! On va l utiliser comme pattern de sortie qui permettra de voir la securite du programme
//cela ne va pas ralentir le language qui est deja tres booste mais ca va de valider le code 
//dans les processeurs multicoeur ! Donc, on a un supercalculateur avec des mutlicoeur pour chaque
//processeur en plus. Tout ca avec un pattern de sortie ! Donc j'ai trouve 2 pattern avec tout ce que
//jai fait !

//la complexite d un programme de modele locale est : j avais entendu la descente de gauss (ou autre
//chose mais peut etre que c t la descente du gradient pour optimiser le modele et recuperer
//le resultat. Donc la complexité est (de tete de moi meme avec log(x) en plus haha !):
//vu que on utilise log(x) depuis longtemps meme avant tout ca, je vais dire que la complexite
//est : 2*n*log(n)*log(n). En effet, le deuxieme log(n) decoule de la physique (c ce ke je pense !)
//JE dis ca car en etudiant navier stokes, j'ai vu que plus complexe c etait l humidite dune chambre.
//et donc,.... non la complexite est plutot : 2*n*log( log(n)) car on peut trouver facilement
//la complexite de l humidité d une chambre alors qu on ne peut pas resoudre navier stokes 
//actuellement. Le log(x) est parfaitement pris et multiplié par 2 car ...(touver une estimation).
//BREF OUUEE ! Tout ce que je dis la n est pas la réalite mais une approximation grossiere lourde.
//Donc le super calculateur devra tout de meme contenir le mot clef inject qui est pareil
//qu en java, c++ (google fruit) ou C. Mais dans certains cas, vu que le code source dans sont
//defilement est coupé en trois parties, on peut s assurer que led injectd ne perdront pas tous leurs temps a.
//defile toute la memoire tout le temps ! C est une optimisation de inject que j ai fait la !

//16.07.2024 Je viens de penser que pour le modele avec des log(x) en intrinseque, on peut mettre
//comme donnee des parties du  code du programme et donc ici, des codes de classes. Mais j'ai pense
//aussi qu il faudra aussi valider le modele. Donc la complexité devient 2*n^2 * log(log(x)) et donc
//o(n) = n^2. Cela peut servir seulement si le programme est tres volumineux car on a n^2 ! Je veux
//dire que dans un programme, on peut avoir plusieurs fois o(n)=n^3 dans differents algo des parties
//du code en temps normal. Deja, de un, ces lart pointer ne devront pas etre du type modele de 
//simulation a cause de log(x) encore une fois ! TRUC DE FOU ! La j ai dis qu un supercalculateur
//ne devra pas utiliser de modeles de simulation, et, donc, qu'est ce que ca veut dire ?
//Ca veut dire que des parties du code source seront optimisé par log(x) sans avoir a optimiser les algo
//eux meme ! Mais quand est-ce que je devrais faire un pre process ou post process des contrats des 
//fonctions des classes alors ? CA ca ressemble a la transofrmation en code native d un code manage !
//Mais j ai enleve certaines fonctions de librairie du C. Alors qu est ce que ca veut dire ?
//Ca veut dire que ce que je viens de faire sont de nouvelles fonctions du language C securisé
//et optimise ! Cela veut peut etre aussi dire qu on a la des smart pointer auto valide !! YEESS ! Donc
//pas besoin de valide les modeles precedant ! Et donc on n aura qu a faire un pre ou post process
//du modele ou des parties du code des classes avec log(x) ! Et comme j utilise encore log(x)
//on n aura qu a faire ce process que pour les premieres lignes du code !
//ca ressemble aussi a un generateur de code mais le plus important c est qu il faut du code "utile"
//donc ca peut servir a trouver le debut, le milieu et la fin d un code separe prealablement en 3.
//Au lieu d utiliser des pointeurs, on peut utiliser ca ! Ca peut servir dans un supercalculateur
//si on pense aussi a la securite !